# MySQL45讲笔记

## MySQL的基础架构

![](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

MySQL分为Server层和存储引擎层

Server层包括连接器、查询缓存、分析器、优化器、执行器

存储引擎层是插件形式的，支持InnoDB MyISAM Memory 等。最常用的是InnoDB。

### 连接器 

负责跟客户端建立链接、获取权限、维持和管理链接。

### 查询缓存

大多数情况下不建议使用查询缓存，因为MySQL的查询缓存失效非常频繁，一旦表更新，该表所有的查询缓存都会被清空，因此最好用于不变的配置表。

MySQL也支持按需使用的方式，需要讲query_cache_type设置成DEMAND。但在MySQL8.

0版本上已经将查询缓存整块功能删掉了。

### 分析器

分析器会先做词法分析，识别输入的SQL语句是否满足MySQL的语法。将字符串识别成表名、字段名。

### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引。或者在一个语句有多表关联的时候，决定各个表的链接顺序。

### 执行器

执行器是执行语句，在开始执行之前需要先判断对表有没有执行查询的权限。如果有则调用引擎提供的接口。

## 日志模块

MySQL的日志模块有两种方式 redo log 和bin log。其中redo log 是InnoDB支持的一种日志方式。

#### redo log

![](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png)

Redo log 使用了WAL（Write-Ahead logging）技术。即先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB引擎会先把记录写到redo log,并更新内存，这个时候更新就算完成了，同时会在适当的时候将操作记录更新到磁盘中。

#### binlog

binlog 称为归档日志。binlog 只能用于归档，没有crash-safe能力。

redo log和bin log的不同

- redo log 是InnoDB特有的 binlog 是MySQL Server实现的。所以引擎都可以使用
- redo log是无力日志，记录的是某个数据做了什么修改，bin log是逻辑日志，记录的是这个语句的原始逻辑。
- redo log 是循环写，空间固定会用完。bin log是追加写，不会覆盖以前的日志。

![](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

其中redo log拆分成了两个步骤，即prepare 和commit 称为两阶段提交。

### 两阶段提交

两阶段提交的用处是为了让两份日志之间逻辑一致。

## 事务

#### 隔离性和隔离级别

当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了隔离级别的概念。

- 脏读：事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据时脏数据。
- 不可重复读：事务A多次读取同一个数据，事务B在事务A多次读取的过程中，对数据做了更新操作，导致A读取到的数据不一致。
- 幻读：新增记录时，事务开始后新增的记录没有被操作。

总结：不可重复读侧重于修改，幻读侧重于新增或删除。一个是更新列，一个是新增或删除记录。一个需要锁行 一个需要锁表。

隔离级别越高，效率也就越低。

SQL标准的事务隔离级别包括了：读未提交、读已移交、可重复读、串行化。

- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读已提交：一个事务提交之后，它做的变更才会被其他事物看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然未提交变更对其他事务也是不可见的。
- 串行化：对同一行记录，读写都加锁。

## 索引

根据叶子结点的内容，索引类型可以分为主键索引和非主键索引。

主键索引的叶子结点存的是整行数据。在InnoDB中也称为局簇索引。

非主键索引的叶子结点存的是主键的值，在InnoDB中也称为二级索引。

- 如果是主键索引，只需要搜索ID这颗B+树
- 如果是非主键缩索引，则查到ID之后还需要再到ID索引树搜索一次，这个过程称为回表。

因此我们在应用中应该尽量使用主键索引。

### 覆盖索引

定义：索引已经覆盖了我们的查询需求，称为覆盖索引。

比如ID在索引树上，则select ID from table where k between 1  and 5 ，结果集ID就在索引树上，因此无需回表，可以提升查询性能。

### 最左原则

在建立联合索引的时候，如何安排索引内的字段顺序？

第一原则是通过调整顺序，可以少维护一个索引，那么这个顺序往往是需要优先考虑采用的。

### 全局锁

全局锁就是对整个数据库实例加锁，命令是Flush tables with read lock。

典型使用场景是做全库逻辑备份。

### 表锁

MySQL的表级别的锁有两种，表锁和元数据锁。

表锁的语法是lock tables  read/write

元数据锁不需要显式声明，在访问一个表的时候会被自动加上。MDL的作用是保证都写的正确性。

### 行锁

MySQL的行锁是由引擎层自己实现的。不是所有的引擎都支持行锁，比如MyISAM就不支持。

## 实践

### 普通索引和唯一索引应该怎么选择

